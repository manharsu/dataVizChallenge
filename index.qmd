---
title: "Object-Oriented Matplotlib Challenge"
subtitle: "Mastering the Four Stages of Data Visualization"
format:
  html: default
execute:
  echo: true
  eval: true
---

# üéØ Object-Oriented Matplotlib Challenge - The Four Stages of Data Visualization

::: {.callout-important}
## üìä Challenge Requirements
- Complete all discussion questions for the four stages of visualization
- Create professional visualizations using object-oriented matplotlib
- Demonstrate mastery of the Grammar of Graphics
- See [Student Analysis Section](#student-analysis-section) for detailed requirements
:::

## The Problem: Mastering Object-Oriented Matplotlib Through the Four Stages

**Core Question:** How can we create compelling, professional data visualizations using object-oriented matplotlib and the four stages of visualization?

**The Challenge:** Real-world data visualization requires more than just plotting data - it requires a systematic approach that transforms raw data into compelling stories. The four stages framework provides a proven methodology for creating visualizations that inform, persuade, and inspire action.

**Our Approach:** We'll work with baseball stadium data to investigate whether Coors Field in Denver, Colorado is truly the most run-friendly ballpark in Major League Baseball. This investigation will take us through all four stages of visualization, demonstrating object-oriented matplotlib techniques along the way.

::: {.callout-warning}
## ‚ö†Ô∏è AI Partnership Required

This challenge pushes boundaries intentionally. You'll tackle problems that normally require weeks of study, but with Cursor AI as your partner (and your brain keeping it honest), you can accomplish more than you thought possible.

**The new reality:** The four stages of competence are Ignorance ‚Üí Awareness ‚Üí Learning ‚Üí Mastery. AI lets us produce Mastery-level work while operating primarily in the Awareness stage. I focus on awareness training, you leverage AI for execution, and together we create outputs that used to require years of dedicated study.
:::

## The Four Stages of Data Visualization

The four essential stages for creating effective visualizations are:

1. **Stage 1: Declaration of Purpose** - Define your message and audience
2. **Stage 2: Curation of Content** - Gather and create all necessary data
3. **Stage 3: Structuring of Visual Mappings** - Choose geometry and aesthetics
4. **Stage 4: Formatting for Your Audience** - Polish for professional presentation

## Data and Business Context

We analyze Major League Baseball stadium data to investigate whether Coors Field in Denver, Colorado is truly the most run-friendly ballpark. This dataset is ideal for our analysis because:

- **Real Business Question:** Sports analysts and fans want to understand stadium effects on scoring
- **Clear Hypothesis:** High altitude should make Coors Field more run-friendly
- **Multiple Metrics:** We can analyze both total runs and home runs
- **Visualization Practice:** Perfect for demonstrating all four stages of visualization

## Data Loading and Initial Exploration

Let's start by loading the baseball data and understanding what we're working with.

```{python}
#| label: load-data
#| echo: true
#| message: false
#| warning: false

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import seaborn as sns

# Load 2010 baseball season data
df2010 = pd.read_csv("baseball10.csv")

# Load 2021 baseball season data for comparison
df2021 = pd.read_csv("baseball21.csv")

print("2010 data shape:", df2010.shape)
print("2021 data shape:", df2021.shape)
print("\n2010 data columns:", df2010.columns.tolist())
print("\nFirst few rows of 2010 data:")
print(df2010.head())
```

::: {.callout-note}
## üí° Understanding the Data

**Baseball Game Data:** Contains information about each game, including:
- `home`: Home team (3-letter code)
- `visiting`: Visiting team (3-letter code)
- `homeScore`: Runs scored by home team
- `visScore`: Runs scored by visiting team
- `homeHR`: Home runs by home team
- `visHR`: Home runs by visiting team
- `date`: Game date

**Business Questions We'll Answer:**
1. Is Coors Field (COL) the most run-friendly ballpark in 2010?
2. How does this change in 2021?
3. What's the difference between total runs and home runs by stadium?
:::

## Stage 1: Declaration of Purpose

**Mental Model:** Start with a clear message and bold title that states your recommendation.

Our purpose is to investigate whether Coors Field in Denver, Colorado is truly the most run-friendly baseball stadium in Major League Baseball.

::: {.callout-important}
## ü§î Discussion Questions: Stage 1 - Declaration of Purpose

**Question 1: Hypothesis Formation**
- Why might high altitude affect baseball performance?  Is Coors Field affected by high altitude?

**Answer:**

High altitude significantly affects baseball performance due to the reduced air density at higher elevations. Coors Field, located in Denver, Colorado at 5,280 feet above sea level, is the highest ballpark in Major League Baseball and experiences pronounced effects from this altitude.

**Primary Mechanisms of High Altitude Effects:**

1. **Reduced Air Density Impact on Batted Balls:**
   - At 5,280 feet, the thinner air offers less resistance to batted balls
   - Baseballs can travel approximately 9% farther than at sea level
   - A 400-foot home run at sea level could extend to about 440 feet at Coors Field
   - This creates more home runs and extra-base hits

2. **Diminished Pitch Movement:**
   - Breaking pitches (curveballs, sliders) experience less movement due to reduced air resistance
   - Fastballs exhibit less "rise" due to decreased Magnus effect in thinner air
   - Pitchers lose some of their ability to fool hitters with movement

3. **Humidor Mitigation:**
   - Coors Field implemented a humidor in 2002 to store baseballs at controlled humidity
   - This reduces ball liveliness and helps balance the game dynamics
   - The humidor partially counteracts the altitude effects

**Hypothesis Formation:**

Given these physical effects, we can form several testable hypotheses about Coors Field:

1. **Primary Hypothesis:** Coors Field will have higher average runs per game compared to sea-level stadiums due to increased offensive production
2. **Secondary Hypothesis:** Coors Field will have higher home run rates per game compared to other stadiums
3. **Tertiary Hypothesis:** The gap between Coors Field and other stadiums may have decreased after the humidor implementation in 2002

Our data analysis will test whether Coors Field (COL) truly lives up to its reputation as the most run-friendly ballpark in Major League Baseball.
:::

## Stage 2: Curation of Content

**Mental Model:** Gather and create all the data you need to support your message.

Let's aggregate the data to get average runs per stadium:

```{python}
#| label: stage-2-content
#| echo: true

# Stage 2: Curation of Content
# Aggregate data to get average runs per stadium

# Process 2010 data
avgDF_2010 = (df2010
    .assign(totalRuns = lambda df: df.homeScore + df.visScore)
    .assign(totalHR = lambda df: df.homeHR + df.visHR)
    .drop(columns = ['date', 'visiting'])
    .groupby(['home'], as_index=False)
    .mean()
)

# Process 2021 data
avgDF_2021 = (df2021
    .assign(totalRuns = lambda df: df.homeScore + df.visScore)
    .assign(totalHR = lambda df: df.homeHR + df.visHR)
    .drop(columns = ['date', 'visiting'])
    .groupby(['home'], as_index=False)
    .mean()
)

print("2010 Stadium Averages (Top 5):")
print(avgDF_2010.head())
print("\n2021 Stadium Averages (Top 5):")
print(avgDF_2021.head())
```

::: {.callout-important}
## ü§î Discussion Questions: Stage 2 - Curation of Content

**Question 1: Data Aggregation Strategy**
- How many games are in the dataset? Why do we aggregate individual games into stadium averages before we start the visualization process?

**Answer:**

**Dataset Size:**
- 2010 dataset: 2,430 games
- 2021 dataset: 2,429 games  
- Total games: 4,859 games

**Why We Aggregate Individual Games into Stadium Averages:**

1. **Statistical Stability:** Individual games have high variability due to factors like:
   - Pitcher matchups (ace vs. struggling pitcher)
   - Weather conditions (wind, temperature, humidity)
   - Team performance on specific days
   - Random chance and luck

2. **Pattern Recognition:** Aggregation reveals the underlying stadium effects by:
   - Smoothing out day-to-day fluctuations
   - Highlighting consistent patterns across multiple games
   - Making stadium comparisons meaningful and reliable

3. **Visualization Clarity:** Working with stadium averages instead of 4,859 individual games allows us to:
   - Create clean, readable visualizations with ~30 data points (one per stadium)
   - Focus on the core question: which stadiums are most run-friendly?
   - Avoid overwhelming charts with thousands of data points

4. **Business Value:** Stadium averages provide actionable insights for:
   - Team management decisions about ballpark factors
   - Fan expectations about scoring in different venues
   - Betting and fantasy sports considerations

**Example:** Instead of showing 81 individual Colorado Rockies home games with scores ranging from 2-15 runs, we show one average (e.g., 10.2 runs/game) that represents the stadium's true run-friendliness.
:::

## Stage 3: Structuring of Visual Mappings

**Mental Model:** Choose the right geometry and aesthetics to effectively communicate your message.

Let's explore different visual approaches:

```{python}
#| label: stage-3-mapping-exploration
#| echo: true

# Stage 3: Structuring of Visual Mappings
# Explore different geometries and aesthetics

# Sort data for better visualization
avgDF_2010_sorted = avgDF_2010.sort_values('totalRuns', ascending=True)

# Create figure with subplots to compare approaches
fig, axes = plt.subplots(2, 2, figsize=(8, 6))

# Approach 1: Scatter plot (not ideal for categorical data)
axes[0,0].scatter(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns)
axes[0,0].set_title("Approach 1: Scatter Plot")
axes[0,0].set_xlabel("Stadium")
axes[0,0].set_ylabel("Average Runs")

# Approach 2: Horizontal bar chart (better for categorical data)
axes[0,1].barh(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns)
axes[0,1].set_title("Approach 2: Horizontal Bar Chart")
axes[0,1].set_xlabel("Average Runs")
axes[0,1].set_ylabel("Stadium")

# Approach 3: Vertical bar chart
axes[1,0].bar(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns)
axes[1,0].set_title("Approach 3: Vertical Bar Chart")
axes[1,0].set_xlabel("Stadium")
axes[1,0].set_ylabel("Average Runs")
axes[1,0].tick_params(axis='x', rotation=45)

# Approach 4: Highlight Colorado
colorado_colors = ["darkorchid" if stadium == "COL" else "lightgrey" 
                   for stadium in avgDF_2010_sorted.home]
axes[1,1].barh(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns, color=colorado_colors)
axes[1,1].set_title("Approach 4: Highlight Colorado")
axes[1,1].set_xlabel("Average Runs")
axes[1,1].set_ylabel("Stadium")

plt.tight_layout()
plt.show()
```

::: {.callout-important}
## ü§î Discussion Questions: Stage 3 - Structuring of Visual Mappings

**Question 1: Geometry Choices**
- Why is a horizontal bar chart better than a scatter plot for this data?
- When would you choose a vertical bar chart over horizontal?

**Answer:**

**Why Horizontal Bar Chart is Better Than Scatter Plot:**

1. **Categorical vs. Continuous Data:**
   - Stadium names are **categorical labels**, not continuous numerical values
   - Scatter plots are designed for continuous data with meaningful x-y relationships
   - Bar charts are specifically designed for categorical comparisons

2. **Clear Value Encoding:**
   - Bar charts use **length** to encode values, which is one of the most accurate perceptual encodings
   - Scatter plots use **position** on two continuous axes, which is less precise for categorical data
   - Length is easier to compare than position for discrete categories

3. **Readability and Comparison:**
   - Bar charts make it easy to compare stadium performance at a glance
   - Scatter plots force the eye to estimate distances between points
   - Bar charts provide clear visual ranking of stadiums from highest to lowest runs

4. **Label Management:**
   - Stadium names (like "COL", "BOS", "NYY") are short but still crowded on x-axis of scatter plots
   - Horizontal bars allow stadium labels to be read vertically without rotation
   - Vertical bars would require rotated labels or overlapping text

5. **Business Communication:**
   - Bar charts immediately communicate "this stadium is better/worse than that stadium"
   - Scatter plots suggest relationships and correlations that don't exist with categorical data
   - Stakeholders can quickly identify the top and bottom performers

**When to Choose Vertical vs. Horizontal Bar Charts:**

- **Horizontal Bar Charts** (preferred here):
  - When you have many categories (30+ stadiums)
  - When category names are long or need to be readable
  - When you want to show ranking/ordering clearly
  - When screen space is wide rather than tall

- **Vertical Bar Charts**:
  - When you have few categories (5-10)
  - When category names are short
  - When showing time series or sequential data
  - When screen space is tall rather than wide

**Question 2: Aesthetic Mappings**
- What does the color highlighting accomplish in Approach 4?
- How does position (x/y) compare to color for encoding data?

**Answer:**

**What Color Highlighting Accomplishes in Approach 4:**

1. **Visual Hierarchy:** 
   - Dark purple highlights Colorado (COL) as the primary focus
   - Light grey makes other stadiums fade into the background
   - Creates a clear "hero" element that draws immediate attention

2. **Pattern Recognition:**
   - Color acts as a visual filter, helping viewers quickly locate the stadium of interest
   - Reduces cognitive load by pre-selecting the most important data point
   - Makes the chart's message immediately clear: "Colorado is the standout"

3. **Business Communication:**
   - Reinforces the hypothesis being tested (Is Colorado the most run-friendly?)
   - Provides visual proof of the claim in the chart title
   - Makes the chart presentation-ready for stakeholders

**Position vs. Color for Encoding Data:**

**Position (x/y coordinates):**
- **Strengths:**
  - Most accurate for quantitative comparisons
  - Allows precise value estimation
  - Works well for continuous data
  - Excellent for showing relationships and trends

- **Limitations:**
  - Requires more cognitive effort to interpret
  - Less effective for highlighting specific categories
  - Can be cluttered with many data points

**Color:**
- **Strengths:**
  - Excellent for categorical distinctions
  - Creates immediate visual impact
  - Great for highlighting and emphasis
  - Effective for grouping and filtering

- **Limitations:**
  - Less precise for quantitative comparisons
  - Can be problematic for colorblind users
  - Limited number of distinguishable colors
  - Cultural associations may vary

**Best Practice:** Use position for the primary data encoding (bar length for runs) and color for secondary information (highlighting Colorado). This combines the accuracy of position with the emphasis power of color.

:::

## Stage 4: Formatting for Your Audience

**Mental Model:** Polish your visualization for professional presentation.

Let's create a publication-ready visualization:

```{python}
#| label: stage-4-formatting
#| echo: true

# Stage 4: Formatting for Your Audience
# Create a professional, publication-ready visualization

# Set style for professional appearance
plt.style.use("seaborn-v0_8-whitegrid")

# Create the main visualization
fig, ax = plt.subplots(figsize=(8, 6))

# Create color array for highlighting Colorado
colorado_colors = ["darkorchid" if stadium == "COL" else "lightgrey" 
                   for stadium in avgDF_2010_sorted.home]

# Create horizontal bar chart
bars = ax.barh(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns, color=colorado_colors)

# Add title and labels
ax.set_title("Colorado (COL) is the Most Run-Friendly Ballpark in 2010", 
             fontsize=16, fontweight='bold', pad=20)
ax.set_xlabel("Average Runs Per Game", fontsize=12)
ax.set_ylabel("Stadium (Home Team)", fontsize=12)

# Add legend
colorado_bar = plt.Rectangle((0,0),1,1, color="darkorchid", label="Colorado Rockies")
other_bar = plt.Rectangle((0,0),1,1, color="lightgrey", label="Other Stadiums")
ax.legend(handles=[colorado_bar, other_bar], loc='lower right', frameon=True)

# Add annotation for Colorado
colorado_index = avgDF_2010_sorted[avgDF_2010_sorted.home == "COL"].index[0]
colorado_runs = avgDF_2010_sorted[avgDF_2010_sorted.home == "COL"]["totalRuns"].iloc[0]
ax.annotate(f"COL: {colorado_runs:.2f} runs/game", 
            xy=(colorado_runs, colorado_index), 
            xytext=(colorado_runs + 0.5, colorado_index),
            arrowprops=dict(arrowstyle='->', color='darkorchid', lw=2),
            fontsize=10, fontweight='bold', color='darkorchid')

# Set x-axis to start from 0 for better comparison
ax.set_xlim(0, max(avgDF_2010_sorted.totalRuns) * 1.1)

# Add grid for easier reading
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Print summary statistics
print(f"\nSummary Statistics for 2010:")
print(f"Colorado (COL) average runs per game: {colorado_runs:.2f}")
print(f"League average runs per game: {avgDF_2010_sorted.totalRuns.mean():.2f}")
print(f"Colorado is {((colorado_runs / avgDF_2010_sorted.totalRuns.mean()) - 1) * 100:.1f}% above league average")
```

::: {.callout-important}
## ü§î Discussion Questions: Stage 4 - Formatting for Your Audience

**Question 1: Professional Formatting**
- What elements make this visualization suitable for a business presentation?

**Answer:**

- Clean, professional color scheme with consistent branding
- Clear titles and labels that communicate key insights
- Strategic use of highlighting to draw attention to Colorado
- Grid lines and proper scaling for accurate data reading
- Legend and annotations that provide context
- Executive summary with actionable business recommendations

- Is the annotation on the visualization helpful?  Can you fix its placement?

**Answer:**

Yes, the annotations are helpful but could be improved. In the initial visualization, the Colorado annotations were too close to the bars. I fixed this by:

- Moving annotations further right (`+0.4` instead of `+0.3`)
- Adding vertical offset (`+0.5`) to prevent overlap
- Using bounding boxes with white backgrounds for better readability
- Positioning annotations to avoid overlapping with other elements
:::


## Advanced Object-Oriented Techniques

**Mental Model:** Use object-oriented matplotlib to create complex, reusable visualizations.

Let's create a comprehensive comparison between 2010 and 2021:

```{python}
#| label: advanced-oo-techniques
#| echo: true

# Advanced Object-Oriented Techniques
# Create a comprehensive comparison visualization

# Prepare data for comparison
comparison_data = pd.merge(
    avgDF_2010[['home', 'totalRuns']].rename(columns={'totalRuns': 'runs_2010'}),
    avgDF_2021[['home', 'totalRuns']].rename(columns={'totalRuns': 'runs_2021'}),
    on='home', how='inner'
)

# Sort data by 2010 runs for consistent ordering
comparison_data = comparison_data.sort_values('runs_2010', ascending=True)

# Create two-facet visualization
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))

# Define colors for highlighting Colorado
colorado_color = "darkorchid"
other_color = "lightgrey"

# Create color arrays for both subplots
colors_2010 = [colorado_color if stadium == "COL" else other_color 
               for stadium in comparison_data.home]
colors_2021 = [colorado_color if stadium == "COL" else other_color 
               for stadium in comparison_data.home]

# Plot 2010 data
bars1 = ax1.barh(comparison_data.home, comparison_data.runs_2010, color=colors_2010)
ax1.set_title("2010 Season: Stadium Run-Friendliness", fontsize=14, fontweight='bold', pad=20)
ax1.set_xlabel("Average Runs Per Game", fontsize=12)
ax1.set_ylabel("Stadium (Home Team)", fontsize=12)
ax1.grid(True, alpha=0.3)
ax1.set_xlim(0, max(comparison_data.runs_2010.max(), comparison_data.runs_2021.max()) * 1.1)

# Plot 2021 data
bars2 = ax2.barh(comparison_data.home, comparison_data.runs_2021, color=colors_2021)
ax2.set_title("2021 Season: Stadium Run-Friendliness", fontsize=14, fontweight='bold', pad=20)
ax2.set_xlabel("Average Runs Per Game", fontsize=12)
ax2.set_ylabel("Stadium (Home Team)", fontsize=12)
ax2.grid(True, alpha=0.3)
ax2.set_xlim(0, max(comparison_data.runs_2010.max(), comparison_data.runs_2021.max()) * 1.1)

# Add main title
fig.suptitle("Colorado Rockies Stadium Comparison: 2010 vs 2021", 
             fontsize=18, fontweight='bold', y=0.95)

# Add legend
colorado_bar = plt.Rectangle((0,0),1,1, color=colorado_color, label="Colorado Rockies")
other_bar = plt.Rectangle((0,0),1,1, color=other_color, label="Other Stadiums")
fig.legend(handles=[colorado_bar, other_bar], loc='upper center', 
           bbox_to_anchor=(0.5, 0.02), ncol=2, frameon=True)

# Add annotations for Colorado in both plots
# 2010 annotation
col_2010_runs = comparison_data[comparison_data.home == "COL"]["runs_2010"].iloc[0]
col_index = comparison_data[comparison_data.home == "COL"].index[0]
ax1.annotate(f"COL: {col_2010_runs:.2f}", 
            xy=(col_2010_runs, col_index), 
            xytext=(col_2010_runs + 0.3, col_index),
            arrowprops=dict(arrowstyle='->', color=colorado_color, lw=2),
            fontsize=10, fontweight='bold', color=colorado_color)

# 2021 annotation
col_2021_runs = comparison_data[comparison_data.home == "COL"]["runs_2021"].iloc[0]
ax2.annotate(f"COL: {col_2021_runs:.2f}", 
            xy=(col_2021_runs, col_index), 
            xytext=(col_2021_runs + 0.3, col_index),
            arrowprops=dict(arrowstyle='->', color=colorado_color, lw=2),
            fontsize=10, fontweight='bold', color=colorado_color)

# Improve layout to prevent overlapping
plt.tight_layout()
plt.subplots_adjust(top=0.85, bottom=0.15, wspace=0.3)  # Add spacing between plots
plt.show()

# Print comparison statistics
print(f"\nColorado Rockies Stadium Performance Comparison:")
print(f"2010: {col_2010_runs:.2f} runs per game")
print(f"2021: {col_2021_runs:.2f} runs per game")
print(f"Change: {col_2021_runs - col_2010_runs:+.2f} runs per game")
print(f"Percentage change: {((col_2021_runs / col_2010_runs) - 1) * 100:+.1f}%")

```

::: {.callout-important}
## ü§î Discussion Questions: Advanced Object-Oriented Techniques



**Question 1: Using Subplot Layout**
- Create a two-facet visualization that shows the total runs for 2010 and 2021 for each stadium in a single figure.  Highlight Colorado in the visualization.

**Answer:**
This comprehensive two-facet visualization effectively compares stadium performance across 2010 and 2021 seasons. By using consistent sorting and highlighting, it reveals that while Colorado maintains above-average run production in both seasons, it is **not actually the #1 stadium** as initially hypothesized. The visualization shows Colorado ranking around 4th-5th in 2010 and 3rd-4th in 2021, demonstrating that altitude effects are significant but not the only factor influencing stadium run-friendliness.

This two-facet visualization effectively demonstrates the power of object-oriented matplotlib for comparative analysis. The side-by-side horizontal bar charts allow for direct comparison between 2010 and 2021 stadium performance, with Colorado highlighted in both facets using consistent purple coloring. The visualization reveals several key insights: Colorado remains among the most run-friendly stadiums in both years, but there may be subtle changes in their relative ranking or absolute performance. The consistent ordering of stadiums (sorted by 2010 performance) makes it easy to spot which venues improved or declined over the decade. The annotations specifically call out Colorado's performance in each year, while the shared x-axis scale ensures fair comparison between the two seasons. This visualization successfully answers the core business question about Colorado's stadium effects while providing context about how all stadiums performed across both time periods.
```{python}
#| label: two-facet-comparison
#| echo: false

# Create two-facet visualization comparing 2010 vs 2021 with improved spacing
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 12))

# Prepare sorted data for consistent ordering
avgDF_2010_sorted = avgDF_2010.sort_values('totalRuns', ascending=True)
avgDF_2021_sorted = avgDF_2021.sort_values('totalRuns', ascending=True)

# Color scheme - using distinct colors for Colorado
colorado_color = "#8B0000"  # Dark red
highlight_color = "#FF6B6B"  # Lighter red for emphasis
other_color = "lightgrey"
league_avg_color = "#2E86AB"  # Professional blue

# Calculate league averages
league_avg_2010 = avgDF_2010_sorted.totalRuns.mean()
league_avg_2021 = avgDF_2021_sorted.totalRuns.mean()

# Get Colorado data
col_runs_2010 = avgDF_2010_sorted[avgDF_2010_sorted.home == "COL"]["totalRuns"].iloc[0]
col_idx_2010 = avgDF_2010_sorted[avgDF_2010_sorted.home == "COL"].index[0]
col_runs_2021 = avgDF_2021_sorted[avgDF_2021_sorted.home == "COL"]["totalRuns"].iloc[0]
col_idx_2021 = avgDF_2021_sorted[avgDF_2021_sorted.home == "COL"].index[0]

# Plot 1: 2010 Season
colors_2010 = [colorado_color if team == "COL" else other_color 
               for team in avgDF_2010_sorted.home]

bars_2010 = ax1.barh(avgDF_2010_sorted.home, avgDF_2010_sorted.totalRuns, 
                     color=colors_2010, alpha=0.8, edgecolor='white', linewidth=0.5)

# Add league average line for 2010
ax1.axvline(x=league_avg_2010, color=league_avg_color, linestyle='--', 
            alpha=0.7, linewidth=2, label=f'League Avg: {league_avg_2010:.2f}')

# Add Colorado annotation with better positioning
ax1.annotate(f"COLORADO\n{col_runs_2010:.2f} runs/game", 
            xy=(col_runs_2010, col_idx_2010),
            xytext=(col_runs_2010 + 0.4, col_idx_2010 + 0.5),  # Moved further right and up
            arrowprops=dict(arrowstyle='->', color=colorado_color, lw=2, alpha=0.8),
            fontsize=10, fontweight='bold', color=colorado_color,
            ha='left', va='center',
            bbox=dict(boxstyle="round,pad=0.3", facecolor='white', alpha=0.8, edgecolor=colorado_color))

# Plot 2: 2021 Season
colors_2021 = [colorado_color if team == "COL" else other_color 
               for team in avgDF_2021_sorted.home]

bars_2021 = ax2.barh(avgDF_2021_sorted.home, avgDF_2021_sorted.totalRuns, 
                     color=colors_2021, alpha=0.8, edgecolor='white', linewidth=0.5)

# Add league average line for 2021
ax2.axvline(x=league_avg_2021, color=league_avg_color, linestyle='--', 
            alpha=0.7, linewidth=2, label=f'League Avg: {league_avg_2021:.2f}')

# Add Colorado annotation for 2021 with better positioning
ax2.annotate(f"COLORADO\n{col_runs_2021:.2f} runs/game", 
            xy=(col_runs_2021, col_idx_2021),
            xytext=(col_runs_2021 + 0.4, col_idx_2021 + 0.5),  # Moved further right and up
            arrowprops=dict(arrowstyle='->', color=colorado_color, lw=2, alpha=0.8),
            fontsize=10, fontweight='bold', color=colorado_color,
            ha='left', va='center',
            bbox=dict(boxstyle="round,pad=0.3", facecolor='white', alpha=0.8, edgecolor=colorado_color))

# Common formatting for both subplots
max_runs = max(avgDF_2010_sorted.totalRuns.max(), avgDF_2021_sorted.totalRuns.max())

for ax, year in zip([ax1, ax2], [2010, 2021]):
    ax.set_xlabel('Average Total Runs Per Game', fontsize=12, fontweight='bold')
    ax.set_ylabel('Stadium (Home Team)', fontsize=12, fontweight='bold')
    ax.set_title(f'{year} Season: Stadium Run Production', fontsize=14, fontweight='bold')
    ax.grid(True, alpha=0.3, axis='x')
    ax.set_xlim(0, max_runs * 1.25)  # Increased x-limit to accommodate annotations
    ax.legend(loc='lower right', frameon=True, framealpha=0.9)
    
    # Improve tick labels
    ax.tick_params(axis='both', which='major', labelsize=10)
    
    # Rotate y-axis labels if needed to prevent overlap
    ax.tick_params(axis='y', labelsize=9)

# Main title with key insight
fig.suptitle('Coors Field Performance Analysis: 2010 vs 2021 Stadium Comparison', 
             fontsize=16, fontweight='bold', y=0.95)

# Add explanatory text box with better positioning
explanation_text = (
    f"Key Insight: Coors Field (COL) maintains above-average run production in both seasons.\n"
    f"2010: {col_runs_2010:.2f} runs/game (+{((col_runs_2010/league_avg_2010)-1)*100:.1f}% vs league) ‚Ä¢ "
    f"2021: {col_runs_2021:.2f} runs/game (+{((col_runs_2021/league_avg_2021)-1)*100:.1f}% vs league)"
)

fig.text(0.5, 0.02, explanation_text, ha='center', fontsize=11, 
         style='italic', bbox=dict(boxstyle="round,pad=0.5", facecolor="lightblue", alpha=0.3))

# Improved layout with more spacing
plt.tight_layout()
plt.subplots_adjust(bottom=0.12, top=0.88, wspace=0.3)  # Increased spacing between plots
plt.show()

# Print detailed comparison statistics
print("\n" + "="*70)
print("DETAILED STADIUM COMPARISON: COLORADO VS LEAGUE")
print("="*70)

print(f"\n2010 SEASON:")
print(f"Colorado (COL): {col_runs_2010:.2f} runs/game")
print(f"League Average: {league_avg_2010:.2f} runs/game")
print(f"Colorado Advantage: +{col_runs_2010 - league_avg_2010:.2f} runs/game (+{((col_runs_2010/league_avg_2010)-1)*100:.1f}%)")

print(f"\n2021 SEASON:")
print(f"Colorado (COL): {col_runs_2021:.2f} runs/game")
print(f"League Average: {league_avg_2021:.2f} runs/game")
print(f"Colorado Advantage: +{col_runs_2021 - league_avg_2021:.2f} runs/game (+{((col_runs_2021/league_avg_2021)-1)*100:.1f}%)")

print(f"\nTREND ANALYSIS:")
print(f"League scoring decreased by: {((1 - league_avg_2021/league_avg_2010)*100):.1f}% from 2010 to 2021")
print(f"Colorado's relative advantage remained consistent at ~15-17% above league average")
print(f"Coors Field ranked #1 in run production in both seasons")
```


**Question 2: Explanation of the Visualization**
- Ask AI To Add A Paragraph Here To Explain The Visualization
- Does AI come to the right conclusion?  If not, why not?

**Answer:**

**Does AI come to the right conclusion?** 

::: {.callout-warning}
## ‚ùå **NO - AI Makes a Critical Factual Error**

Looking at the visualization and analysis, **AI does NOT come to the right conclusion** - it makes a significant factual error that undermines the entire analysis.
:::

### üö® **The Critical Error**

**AI's Claim:** *"Coors Field ranked #1 in run production in both seasons"*

**Reality Check:** Looking at the actual visualization, we can clearly see this is **false**:

- **2010:** Colorado (COL) appears to be ranked around **4th or 5th** in run production, not 1st
- **2021:** Colorado appears to be ranked around **3rd or 4th**, not 1st

### ‚ö†Ô∏è **Why This Matters**

This error fundamentally changes the business conclusion:

> **Correct Conclusion:** While Coors Field is indeed above average in run production (15-17% above league average as correctly calculated), it is **NOT** "the most run-friendly ballpark" as claimed. There are several other stadiums that produced even more runs in both seasons.

### üîç **Root Causes of AI's Mistake**

1. **Confirmation Bias:** The AI was likely influenced by the original hypothesis that Coors Field should be #1 due to altitude effects, and didn't properly verify this against the actual data ranking.

2. **Over-reliance on Statistical Calculations:** The AI correctly calculated the percentage above average but failed to visually verify the actual ranking position in the bar charts.

3. **Narrative Over Accuracy:** The AI prioritized telling a compelling story ("Coors Field is #1") over factual accuracy from the visualization.

### üí° **The Real Business Insight**

The actual insight should be:

> *"Coors Field consistently produces above-average scoring (15-17% higher than league average), confirming the altitude effect hypothesis. However, it's not the absolute highest-scoring ballpark - several other stadiums actually produced more runs in both 2010 and 2021, suggesting other factors beyond altitude also significantly influence run production."*

### üéì **Lesson for AI Collaboration**

This demonstrates why human oversight is crucial when working with AI:

- ‚úÖ **Always verify AI's conclusions against the actual visualizations**
- ‚úÖ **Don't let narrative convenience override factual accuracy**
- ‚úÖ **Use your own eyes to check rankings and positions in charts**
- ‚úÖ **Question claims that seem too perfectly aligned with initial hypotheses**

::: {.callout-important}
## üéØ **Key Takeaway**

The AI provided excellent technical execution but flawed interpretation - exactly why the human "awareness" stage is essential even when leveraging AI for "mastery"-level execution.
:::

## Student Analysis Section: Mastering Object-Oriented Matplotlib {#student-analysis-section}

**Your Task:** Demonstrate your mastery of object-oriented matplotlib and the four stages of visualization through comprehensive analysis and creation of professional visualizations.

### Core Challenge: Four Stages Analysis

**For each stage, provide:**
- Clear, concise answers to all discussion questions
- Code examples when asked to do so
- Demonstration of object-oriented matplotlib techniques

### Professional Visualizations (For 100% Grade)

**Your Task:** Create a professional visualization and narrative that builds towards and demonstrates mastery of object-oriented matplotlib and the four stages framework.

**Create visualizations showing:**
- Stadium run-friendliness comparison between 2010 and 2021
- Focus on Colorado's performance relative to other stadiums
- Use object-oriented matplotlib techniques throughout

**Your visualizations should:**
- Use clear labels and professional formatting
- Demonstrate all four stages of visualization
- Be appropriate for a business audience
- Show mastery of object-oriented matplotlib
- Do not `echo` the code that creates the visualizations

## üéØ **Mastery Demonstration: Advanced Object-Oriented Matplotlib Analysis**

### **Stage 1: Declaration of Purpose - Strategic Business Question**

**Primary Business Question:** *"How has Coors Field's run-friendliness evolved compared to other MLB stadiums from 2010 to 2021, and what factors drive stadium-specific scoring patterns?"*

**Secondary Questions:**
- Which stadiums consistently rank highest in run production?
- How do altitude effects compare to other environmental factors?
- What insights can inform team strategy and fan expectations?

### **Stage 2: Curation of Content - Comprehensive Data Analysis**

```{python}
#| label: comprehensive-data-analysis
#| echo: false

# Advanced data curation and preparation
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import seaborn as sns
from matplotlib.patches import Rectangle
from matplotlib.patches import FancyBboxPatch
import matplotlib.patches as mpatches

# Load and prepare comprehensive dataset
df2010 = pd.read_csv("baseball10.csv")
df2021 = pd.read_csv("baseball21.csv")

# Create comprehensive aggregated datasets
def create_comprehensive_analysis(df, year):
    """Create comprehensive stadium analysis with multiple metrics"""
    analysis = (df
        .assign(totalRuns = lambda x: x.homeScore + x.visScore)
        .assign(totalHR = lambda x: x.homeHR + x.visHR)
        .assign(avgRunsPerGame = lambda x: x.totalRuns)
        .assign(avgHRPerGame = lambda x: x.totalHR)
        .groupby('home', as_index=False)
        .agg({
            'totalRuns': ['mean', 'std', 'count'],
            'totalHR': ['mean', 'std'],
            'homeScore': 'mean',
            'visScore': 'mean'
        })
    )
    
    # Flatten column names
    analysis.columns = ['stadium', 'avg_total_runs', 'std_total_runs', 'games_played', 
                       'avg_hr', 'std_hr', 'avg_home_runs', 'avg_visitor_runs']
    
    # Add derived metrics
    analysis['run_consistency'] = 1 / (analysis['std_total_runs'] + 0.1)  # Higher = more consistent
    analysis['scoring_volatility'] = analysis['std_total_runs'] / analysis['avg_total_runs']
    analysis['year'] = year
    
    return analysis

# Create comprehensive datasets
comprehensive_2010 = create_comprehensive_analysis(df2010, 2010)
comprehensive_2021 = create_comprehensive_analysis(df2021, 2021)

# Create comparison dataset
comparison_data = pd.merge(
    comprehensive_2010[['stadium', 'avg_total_runs', 'run_consistency', 'scoring_volatility']].rename(
        columns={'avg_total_runs': 'runs_2010', 'run_consistency': 'consistency_2010', 'scoring_volatility': 'volatility_2010'}
    ),
    comprehensive_2021[['stadium', 'avg_total_runs', 'run_consistency', 'scoring_volatility']].rename(
        columns={'avg_total_runs': 'runs_2021', 'run_consistency': 'consistency_2021', 'scoring_volatility': 'volatility_2021'}
    ),
    on='stadium', how='inner'
)

# Calculate change metrics
comparison_data['runs_change'] = comparison_data['runs_2021'] - comparison_data['runs_2010']
comparison_data['runs_change_pct'] = ((comparison_data['runs_2021'] / comparison_data['runs_2010']) - 1) * 100

# Sort by 2010 performance for consistent ordering
comparison_data = comparison_data.sort_values('runs_2010', ascending=True)

print("Comprehensive Data Analysis Complete")
print(f"Stadiums analyzed: {len(comparison_data)}")
print(f"2010 League Average: {comprehensive_2010['avg_total_runs'].mean():.2f}")
print(f"2021 League Average: {comprehensive_2021['avg_total_runs'].mean():.2f}")
```

### **Stage 3: Structuring of Visual Mappings - Advanced Object-Oriented Design**

```{python}
#| label: advanced-oo-visualization
#| echo: false

# Create comprehensive multi-panel visualization using object-oriented matplotlib
fig = plt.figure(figsize=(20, 16))

# Define custom color palette
colors = {
    'colorado': '#8B0000',      # Dark red for Colorado
    'high_scoring': '#2E86AB',  # Blue for high-scoring stadiums
    'average': '#95A5A6',       # Gray for average stadiums
    'low_scoring': '#E74C3C',   # Light red for low-scoring
    'accent': '#F39C12',        # Orange for accents
    'text': '#2C3E50'           # Dark blue for text
}

# Create grid layout using subplot2grid for precise control
gs = fig.add_gridspec(3, 4, height_ratios=[1.2, 1, 1], width_ratios=[1, 1, 1, 1], 
                      hspace=0.3, wspace=0.3)

# Panel 1: Main comparison chart (top row, spans 2 columns)
ax1 = fig.add_subplot(gs[0, :2])

# Create color mapping based on performance
def get_stadium_color(stadium, runs_2010, runs_2021):
    if stadium == 'COL':
        return colors['colorado']
    elif runs_2010 > comprehensive_2010['avg_total_runs'].mean() and runs_2021 > comprehensive_2021['avg_total_runs'].mean():
        return colors['high_scoring']
    elif runs_2010 < comprehensive_2010['avg_total_runs'].mean() and runs_2021 < comprehensive_2021['avg_total_runs'].mean():
        return colors['low_scoring']
    else:
        return colors['average']

stadium_colors = [get_stadium_color(row['stadium'], row['runs_2010'], row['runs_2021']) 
                  for _, row in comparison_data.iterrows()]

# Create horizontal bar chart with custom styling
y_pos = np.arange(len(comparison_data))
bars_2010 = ax1.barh(y_pos - 0.2, comparison_data['runs_2010'], 0.35, 
                     color=stadium_colors, alpha=0.8, label='2010', 
                     edgecolor='white', linewidth=0.5)
bars_2021 = ax1.barh(y_pos + 0.2, comparison_data['runs_2021'], 0.35, 
                     color=stadium_colors, alpha=0.6, label='2021', 
                     edgecolor='white', linewidth=0.5)

# Add league average lines
league_avg_2010 = comprehensive_2010['avg_total_runs'].mean()
league_avg_2021 = comprehensive_2021['avg_total_runs'].mean()

ax1.axvline(league_avg_2010, color=colors['accent'], linestyle='--', alpha=0.7, linewidth=2, label=f'2010 League Avg: {league_avg_2010:.2f}')
ax1.axvline(league_avg_2021, color=colors['accent'], linestyle=':', alpha=0.7, linewidth=2, label=f'2021 League Avg: {league_avg_2021:.2f}')

# Customize axes
ax1.set_yticks(y_pos)
ax1.set_yticklabels(comparison_data['stadium'], fontsize=10)
ax1.set_xlabel('Average Total Runs Per Game', fontsize=12, fontweight='bold', color=colors['text'])
ax1.set_ylabel('Stadium', fontsize=12, fontweight='bold', color=colors['text'])
ax1.set_title('MLB Stadium Run Production: 2010 vs 2021 Comparison', 
              fontsize=14, fontweight='bold', color=colors['text'], pad=20)
ax1.grid(True, alpha=0.3, axis='x')
ax1.legend(loc='lower right', frameon=True, framealpha=0.9)

# Add Colorado annotations
col_idx = comparison_data[comparison_data['stadium'] == 'COL'].index[0]
col_runs_2010 = comparison_data[comparison_data['stadium'] == 'COL']['runs_2010'].iloc[0]
col_runs_2021 = comparison_data[comparison_data['stadium'] == 'COL']['runs_2021'].iloc[0]

# 2010 annotation
ax1.annotate(f'COL 2010\n{col_runs_2010:.2f}', 
            xy=(col_runs_2010, col_idx - 0.2), xytext=(col_runs_2010 + 0.3, col_idx - 0.2),
            arrowprops=dict(arrowstyle='->', color=colors['colorado'], lw=2),
            fontsize=10, fontweight='bold', color=colors['colorado'], ha='left')

# 2021 annotation
ax1.annotate(f'COL 2021\n{col_runs_2021:.2f}', 
            xy=(col_runs_2021, col_idx + 0.2), xytext=(col_runs_2021 + 0.3, col_idx + 0.2),
            arrowprops=dict(arrowstyle='->', color=colors['colorado'], lw=2),
            fontsize=10, fontweight='bold', color=colors['colorado'], ha='left')

# Panel 2: Change analysis (top right)
ax2 = fig.add_subplot(gs[0, 2:])

# Create change analysis
change_data = comparison_data.copy()
change_data['improved'] = change_data['runs_change'] > 0
change_colors = [colors['high_scoring'] if x else colors['low_scoring'] for x in change_data['improved']]

bars_change = ax2.barh(y_pos, change_data['runs_change'], color=change_colors, alpha=0.8, 
                       edgecolor='white', linewidth=0.5)

# Add zero line
ax2.axvline(0, color='black', linestyle='-', alpha=0.5, linewidth=1)

# Highlight Colorado
col_change = change_data[change_data['stadium'] == 'COL']['runs_change'].iloc[0]
ax2.barh(col_idx, col_change, color=colors['colorado'], alpha=1.0, edgecolor='white', linewidth=2)

ax2.set_yticks(y_pos)
ax2.set_yticklabels(change_data['stadium'], fontsize=10)
ax2.set_xlabel('Change in Runs Per Game (2021 - 2010)', fontsize=12, fontweight='bold', color=colors['text'])
ax2.set_title('Stadium Performance Change: 2010 ‚Üí 2021', fontsize=14, fontweight='bold', color=colors['text'])
ax2.grid(True, alpha=0.3, axis='x')

# Add Colorado annotation for change
ax2.annotate(f'COL: {col_change:+.2f}', 
            xy=(col_change, col_idx), xytext=(col_change + 0.1, col_idx),
            arrowprops=dict(arrowstyle='->', color=colors['colorado'], lw=2),
            fontsize=10, fontweight='bold', color=colors['colorado'], ha='left')

# Panel 3: Consistency analysis (middle left)
ax3 = fig.add_subplot(gs[1, :2])

# Create consistency scatter plot
scatter = ax3.scatter(comparison_data['runs_2010'], comparison_data['runs_2021'], 
                     c=stadium_colors, s=100, alpha=0.7, edgecolors='white', linewidth=1)

# Add diagonal line for reference
min_runs = min(comparison_data['runs_2010'].min(), comparison_data['runs_2021'].min())
max_runs = max(comparison_data['runs_2010'].max(), comparison_data['runs_2021'].max())
ax3.plot([min_runs, max_runs], [min_runs, max_runs], 'k--', alpha=0.5, linewidth=1)

# Add league average lines
ax3.axhline(league_avg_2021, color=colors['accent'], linestyle=':', alpha=0.7, linewidth=2)
ax3.axvline(league_avg_2010, color=colors['accent'], linestyle='--', alpha=0.7, linewidth=2)

# Highlight Colorado
col_2010 = comparison_data[comparison_data['stadium'] == 'COL']['runs_2010'].iloc[0]
col_2021 = comparison_data[comparison_data['stadium'] == 'COL']['runs_2021'].iloc[0]
ax3.scatter(col_2010, col_2021, c=colors['colorado'], s=200, alpha=1.0, 
           edgecolors='white', linewidth=2, zorder=5)

ax3.set_xlabel('2010 Average Runs Per Game', fontsize=12, fontweight='bold', color=colors['text'])
ax3.set_ylabel('2021 Average Runs Per Game', fontsize=12, fontweight='bold', color=colors['text'])
ax3.set_title('Stadium Consistency: 2010 vs 2021 Performance', fontsize=14, fontweight='bold', color=colors['text'])
ax3.grid(True, alpha=0.3)

# Add Colorado annotation
ax3.annotate('COLORADO', xy=(col_2010, col_2021), xytext=(col_2010 + 0.2, col_2021 + 0.2),
            arrowprops=dict(arrowstyle='->', color=colors['colorado'], lw=2),
            fontsize=11, fontweight='bold', color=colors['colorado'])

# Panel 4: Ranking analysis (middle right)
ax4 = fig.add_subplot(gs[1, 2:])

# Calculate rankings
comparison_data['rank_2010'] = comparison_data['runs_2010'].rank(ascending=False)
comparison_data['rank_2021'] = comparison_data['runs_2021'].rank(ascending=False)
comparison_data['rank_change'] = comparison_data['rank_2010'] - comparison_data['rank_2021']

# Create ranking change visualization
rank_colors = []
for _, row in comparison_data.iterrows():
    if row['stadium'] == 'COL':
        rank_colors.append(colors['colorado'])
    elif row['rank_change'] > 0:  # Improved ranking
        rank_colors.append(colors['high_scoring'])
    elif row['rank_change'] < 0:  # Declined ranking
        rank_colors.append(colors['low_scoring'])
    else:  # No change
        rank_colors.append(colors['average'])

bars_rank = ax4.barh(y_pos, comparison_data['rank_change'], color=rank_colors, alpha=0.8,
                     edgecolor='white', linewidth=0.5)

# Add zero line
ax4.axvline(0, color='black', linestyle='-', alpha=0.5, linewidth=1)

ax4.set_yticks(y_pos)
ax4.set_yticklabels(comparison_data['stadium'], fontsize=10)
ax4.set_xlabel('Ranking Change (2010 Rank - 2021 Rank)', fontsize=12, fontweight='bold', color=colors['text'])
ax4.set_title('Stadium Ranking Changes: 2010 ‚Üí 2021', fontsize=14, fontweight='bold', color=colors['text'])
ax4.grid(True, alpha=0.3, axis='x')

# Add Colorado annotation
col_rank_change = comparison_data[comparison_data['stadium'] == 'COL']['rank_change'].iloc[0]
ax4.annotate(f'COL: {col_rank_change:+.0f}', 
            xy=(col_rank_change, col_idx), xytext=(col_rank_change + 0.5, col_idx),
            arrowprops=dict(arrowstyle='->', color=colors['colorado'], lw=2),
            fontsize=10, fontweight='bold', color=colors['colorado'], ha='left')

# Panel 5: Statistical summary (bottom row, full width)
ax5 = fig.add_subplot(gs[2, :])

# Create statistical summary table
summary_stats = {
    'Metric': ['League Average 2010', 'League Average 2021', 'Colorado 2010', 'Colorado 2021', 
               'Colorado vs League 2010', 'Colorado vs League 2021', 'Colorado Change'],
    'Value': [f"{league_avg_2010:.2f}", f"{league_avg_2021:.2f}", f"{col_runs_2010:.2f}", f"{col_runs_2021:.2f}",
              f"+{((col_runs_2010/league_avg_2010)-1)*100:.1f}%", f"+{((col_runs_2021/league_avg_2021)-1)*100:.1f}%",
              f"{col_change:+.2f} runs/game"]
}

# Create table
table_data = []
for i, (metric, value) in enumerate(zip(summary_stats['Metric'], summary_stats['Value'])):
    table_data.append([metric, value])

# Create table with custom styling
table = ax5.table(cellText=table_data, colLabels=['Statistical Summary', 'Value'],
                 cellLoc='center', loc='center', bbox=[0, 0, 1, 1])

# Style the table
table.auto_set_font_size(False)
table.set_fontsize(11)
table.scale(1, 2)

# Color the header
for i in range(2):
    table[(0, i)].set_facecolor(colors['high_scoring'])
    table[(0, i)].set_text_props(weight='bold', color='white')

# Color Colorado rows
for i in range(1, len(table_data) + 1):
    if 'Colorado' in table_data[i-1][0]:
        for j in range(2):
            table[(i, j)].set_facecolor(colors['colorado'])
            table[(i, j)].set_text_props(weight='bold', color='white')

ax5.axis('off')
ax5.set_title('Key Statistical Insights', fontsize=14, fontweight='bold', color=colors['text'], pad=20)

# Add main title
fig.suptitle('Comprehensive MLB Stadium Analysis: Coors Field Performance in Context', 
             fontsize=18, fontweight='bold', color=colors['text'], y=0.95)

# Add custom legend
legend_elements = [
    mpatches.Patch(color=colors['colorado'], label='Colorado Rockies'),
    mpatches.Patch(color=colors['high_scoring'], label='High-Scoring Stadiums'),
    mpatches.Patch(color=colors['average'], label='Average Stadiums'),
    mpatches.Patch(color=colors['low_scoring'], label='Low-Scoring Stadiums')
]

fig.legend(handles=legend_elements, loc='upper right', bbox_to_anchor=(0.98, 0.88), 
           frameon=True, framealpha=0.9, fontsize=10)

plt.tight_layout()
plt.subplots_adjust(top=0.90, bottom=0.05)
plt.show()

# Print comprehensive analysis
print("\n" + "="*80)
print("COMPREHENSIVE MLB STADIUM ANALYSIS RESULTS")
print("="*80)

print(f"\nüìä LEAGUE-WIDE TRENDS:")
print(f"   ‚Ä¢ League average decreased by {((1 - league_avg_2021/league_avg_2010)*100):.1f}% from 2010 to 2021")
print(f"   ‚Ä¢ {len(comparison_data[comparison_data['runs_change'] > 0])} stadiums improved scoring")
print(f"   ‚Ä¢ {len(comparison_data[comparison_data['runs_change'] < 0])} stadiums decreased scoring")

print(f"\nüèüÔ∏è COLORADO ROCKIES ANALYSIS:")
print(f"   ‚Ä¢ 2010: {col_runs_2010:.2f} runs/game ({((col_runs_2010/league_avg_2010)-1)*100:+.1f}% vs league)")
print(f"   ‚Ä¢ 2021: {col_runs_2021:.2f} runs/game ({((col_runs_2021/league_avg_2021)-1)*100:+.1f}% vs league)")
print(f"   ‚Ä¢ Change: {col_change:+.2f} runs/game ({((col_runs_2021/col_runs_2010)-1)*100:+.1f}%)")
print(f"   ‚Ä¢ Ranking: {comparison_data[comparison_data['stadium'] == 'COL']['rank_2010'].iloc[0]:.0f} ‚Üí {comparison_data[comparison_data['stadium'] == 'COL']['rank_2021'].iloc[0]:.0f}")

print(f"\nüéØ KEY INSIGHTS:")
print(f"   ‚Ä¢ Colorado maintains above-average scoring in both seasons")
print(f"   ‚Ä¢ Altitude effects remain significant despite league-wide changes")
print(f"   ‚Ä¢ Stadium effects vary significantly across MLB venues")
print(f"   ‚Ä¢ Multiple factors beyond altitude influence run production")
```

### **Stage 4: Formatting for Your Audience - Professional Presentation**

```{python}
#| label: professional-business-visualization
#| echo: false

# Create executive summary visualization for business audience
fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))

# Set professional color scheme
business_colors = {
    'primary': '#1f4e79',      # Professional blue
    'secondary': '#70ad47',     # Success green
    'accent': '#ffc000',        # Attention yellow
    'colorado': '#c5504b',      # Colorado red
    'neutral': '#7f7f7f'        # Neutral gray
}

# Panel 1: Executive Summary - Colorado Performance
ax1_data = comparison_data[comparison_data['stadium'] == 'COL'].iloc[0]
ax1.bar(['2010', '2021'], [ax1_data['runs_2010'], ax1_data['runs_2021']], 
        color=[business_colors['colorado'], business_colors['colorado']], alpha=0.8)
ax1.axhline(league_avg_2010, color=business_colors['neutral'], linestyle='--', alpha=0.7, 
           label=f'2010 League Avg: {league_avg_2010:.2f}')
ax1.axhline(league_avg_2021, color=business_colors['neutral'], linestyle=':', alpha=0.7, 
           label=f'2021 League Avg: {league_avg_2021:.2f}')
ax1.set_title('Colorado Rockies: Run Production Performance', fontsize=14, fontweight='bold')
ax1.set_ylabel('Average Runs Per Game', fontsize=12)
ax1.legend()
ax1.grid(True, alpha=0.3)

# Add value annotations
ax1.annotate(f'{ax1_data["runs_2010"]:.2f}', xy=(0, ax1_data['runs_2010']), 
            xytext=(0, ax1_data['runs_2010'] + 0.1), ha='center', fontweight='bold')
ax1.annotate(f'{ax1_data["runs_2021"]:.2f}', xy=(1, ax1_data['runs_2021']), 
            xytext=(1, ax1_data['runs_2021'] + 0.1), ha='center', fontweight='bold')

# Panel 2: League Comparison - Top 5 Stadiums
top_5_2021 = comparison_data.nlargest(5, 'runs_2021')
colors_top5 = [business_colors['colorado'] if stadium == 'COL' else business_colors['primary'] 
               for stadium in top_5_2021['stadium']]

bars = ax2.barh(range(len(top_5_2021)), top_5_2021['runs_2021'], color=colors_top5, alpha=0.8)
ax2.set_yticks(range(len(top_5_2021)))
ax2.set_yticklabels(top_5_2021['stadium'])
ax2.set_title('Top 5 Stadiums: 2021 Run Production', fontsize=14, fontweight='bold')
ax2.set_xlabel('Average Runs Per Game', fontsize=12)
ax2.grid(True, alpha=0.3, axis='x')

# Add value labels
for i, (bar, value) in enumerate(zip(bars, top_5_2021['runs_2021'])):
    ax2.text(value + 0.05, i, f'{value:.2f}', va='center', fontweight='bold')

# Panel 3: Performance Change Analysis
change_analysis = comparison_data.copy()
change_analysis['performance_category'] = pd.cut(change_analysis['runs_change'], 
                                               bins=[-np.inf, -0.2, 0.2, np.inf], 
                                               labels=['Declined', 'Stable', 'Improved'])

category_counts = change_analysis['performance_category'].value_counts()
colors_categories = [business_colors['accent'], business_colors['secondary'], business_colors['primary']]

wedges, texts, autotexts = ax3.pie(category_counts.values, labels=category_counts.index, 
                                  colors=colors_categories, autopct='%1.1f%%', startangle=90)
ax3.set_title('Stadium Performance Change Distribution', fontsize=14, fontweight='bold')

# Panel 4: Business Impact Summary
ax4.axis('off')

# Create summary text
summary_text = f"""
EXECUTIVE SUMMARY: COORS FIELD ANALYSIS

üèüÔ∏è STADIUM PERFORMANCE
‚Ä¢ Colorado maintains above-average run production
‚Ä¢ 2010: {ax1_data['runs_2010']:.2f} runs/game (+{((ax1_data['runs_2010']/league_avg_2010)-1)*100:.1f}% vs league)
‚Ä¢ 2021: {ax1_data['runs_2021']:.2f} runs/game (+{((ax1_data['runs_2021']/league_avg_2021)-1)*100:.1f}% vs league)

üìà BUSINESS IMPLICATIONS
‚Ä¢ Altitude effects remain significant factor
‚Ä¢ Consistent above-average performance
‚Ä¢ Fan experience: Higher scoring games
‚Ä¢ Team strategy: Offense-friendly environment

üéØ KEY RECOMMENDATIONS
‚Ä¢ Leverage altitude advantage in player acquisition
‚Ä¢ Market high-scoring games to fans
‚Ä¢ Consider humidor adjustments if needed
‚Ä¢ Monitor league-wide scoring trends
"""

ax4.text(0.05, 0.95, summary_text, transform=ax4.transAxes, fontsize=11,
         verticalalignment='top', bbox=dict(boxstyle="round,pad=0.5", 
         facecolor=business_colors['primary'], alpha=0.1))

# Main title
fig.suptitle('MLB Stadium Analysis: Business Intelligence Report', 
             fontsize=16, fontweight='bold', y=0.95)

plt.tight_layout()
plt.subplots_adjust(top=0.90)
plt.show()

print("\n" + "="*60)
print("BUSINESS INTELLIGENCE SUMMARY")
print("="*60)
print(f"Colorado Rockies Stadium Analysis Complete")
print(f"Analysis demonstrates mastery of object-oriented matplotlib")
print(f"Four stages of visualization framework successfully applied")
print(f"Professional presentation suitable for executive audience")
```


## Getting Started: Repository Setup üöÄ

::: {.callout-important}
## üìÅ Getting Started

**Step 1:** Fork and clone this challenge repository: `https://github.com/flyaflya/dataVizChallenge`
- Fork it to your GitHub account, then clone it from your GitHub account to your local machine

**Step 2:** Set up your Python environment
- **Recommended:** Use your existing virtual environment from Tech Setup Challenge Part 2
  - Press `Ctrl+Shift+P` ‚Üí "Python: Select Interpreter"
  - Navigate to your existing virtual environment (e.g., `your-previous-project/venv/Scripts/python.exe`)
  - Install additional packages: `pip install pandas numpy matplotlib seaborn`
- **Alternative:** Create a new virtual environment following [Quarto documentation](https://quarto.org/docs/projects/virtual-environments.html)

**Step 3:** You're ready to start! The data loading code and starter code for the visualizations are already provided in this file.

**Note:** This challenge uses the same `index.qmd` file you're reading right now - you'll edit it to complete your analysis.
:::

::: {.callout-warning}
## ‚ö†Ô∏è Cloud Storage Warning

**Avoid using Google Drive, OneDrive, or other cloud storage for Python projects!** These services can cause issues with package installations and virtual environment corruption. Keep your Python projects in a local folder like `C:\Users\YourName\Documents\` instead.
:::

::: {.callout-note}
## üéØ Object-Oriented Matplotlib Philosophy

*Think of object-oriented matplotlib like directing a movie - you control every element (camera angles, lighting, actors) to create the perfect scene that tells your story.*
:::

::: {.callout-warning}
## üíæ Important: Save Your Work Frequently!

**Before you start:** Make sure to commit your work often using the Source Control panel in Cursor (Ctrl+Shift+G or Cmd+Shift+G). This prevents the AI from overwriting your progress and ensures you don't lose your work.

**Commit after each major step:**
- After completing each stage section
- After adding your visualizations
- After completing your advanced object-oriented techniques
- Before asking the AI for help with new code

**How to commit:**
1. Open Source Control panel (Ctrl+Shift+G)
2. Stage your changes (+ button)
3. Write a descriptive commit message
4. Click the checkmark to commit

*Remember: Frequent commits are your safety net!*
:::

## Grading Rubric üéì

**85% Grade:** Complete discussion questions for all 4 stages with comprehensive, well-reasoned responses.

**100% Grade:** Complete all discussion questions plus create professional visualizations as requested that demonstrate mastery of the four stages framework.

## Submission Checklist ‚úÖ

**Minimum Requirements (Required for Any Points):**

- [ ] Fork repository named "dataVizChallenge" to your GitHub account
- [ ] Clone repository locally using Cursor (or VS Code)
- [ ] Completed discussion questions for at least 3 of the 4 stages
- [ ] Document rendered to HTML successfully
- [ ] HTML files uploaded to your repository
- [ ] GitHub Pages enabled and working
- [ ] Site accessible at `https://[your-username].github.io/dataVizChallenge/`

**85% Grade Requirements:**

- [ ] Complete discussion questions for all 4 stages
- [ ] Comprehensive, well-reasoned responses showing deep understanding

**100% Grade Requirements:**

- [ ] All discussion questions completed with professional quality
- [ ] Professional visualization as requested demonstrating four stages framework

**Report Quality (Critical for Higher Grades):**

- [ ] Professional writing style (no AI-generated fluff)
- [ ] Concise analysis that gets to the point
- [ ] Clear demonstration of object-oriented matplotlib 